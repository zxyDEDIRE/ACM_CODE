**同余最短路**常常用于解决这样一类问题：
> 给出 &n& 个整数，每个整数可以取任意多次，询问关于它们能拼凑出的数的一些信息

例如，可能询问这些整数可以拼凑出多少 $[l,r]$  范围之内的数。

当然很容易想到完全背包之类的东西，它的时间复杂度是 $O(nV)$ ( $V$ 表示询问的值域)。。同余最短路为解决这类问题提供了一种复杂度与询问无关的方法。

我们从**同余**的角度考虑问题。我们考虑**模** $A_1$ 的每个同余类 $[x]$ ，一旦我们能用 $A_2,\cdots,A_n$ 凑出 $[x]$ 中的某个数，那么 $[x]$ 中的每个大于等于 $x$ 的数都可以凑出，因为可以不断地加 $A_1$。例如，如果 $A=(5,7,11)$，因为 $7$ 和 $11$ 可以凑出模 $[3]$ 中的 $18$，所以 $[3]$ 中大于等于 $18$ 数 $(18,23,28,\codts)$ 都可以用 $A_1$ 凑出来，因为可以不断的加 $A_1$。

这启示我们，只要知道每个同余类中能被凑出来的最小的数，就可以解决问题。设 $m$ 同余类 $[x]$ 中能凑出来的最小的数位 $d$ ，则在 $[0,r]$ 中能凑出的 $[x]$ 中的数的个数位 $\lfloor \frac{r-d}{m} \rfloor+1$ $(r \leq d)$ 。  

这可以被转化为一个图论问题。我们对于模 $A_1$ 的每个**同余类**建出一个**节点**，向它加 $A_i(i=2,3,\cdots , n)$ 后的对应节点连一条边，边权为 $A_i$。那么每个同余类中能被凑出的最小数就是从 $[0]$ 到它的最短路的长度。

~~~cpp
void solve()
{
	cin>>h>>x>>y>>z;
	if(x==1 || y==1 || z==1){cout<<h;return ;}
	if(x>y)swap(x,y);
	if(x>z)swap(x,z);
	for(int i=0;i<x;i++)
	{
		v[i].push_back({(i+y)%x,y});
		v[i].push_back({(i+z)%x,z});
	}
	dij();
	ll ans=0;
	for(int i=0;i<x;i++)
		if(dis[i]<=h)
		ans+=(h-dis[i])/x+1;
	cout<<ans<<endl;
}
~~~






题目描述：\par
墨墨突然对等式很感兴趣，他正在研究 $( \sum_{i=1}^n a_ix_i)=b$ 存在非负整数解的条件，他要求你编写一个程序，给定 $n, a_{1\dots n}, l, r$，求出有多少 $b\in[l,r]$ 可以使等式存在非负整数解。\par
输入格式:\par
第一行三个整数 $n,l,r$。\par
第二行 $n$ 个整数 $a_{1\dots n}$。\par
输出格式:\par
一行一个整数，表示有多少 $b\in[l,r]$ 可以使等式存在非负整数解。\par
对于 $100\%$ 的数据，$n \le 12$，$0 \le a_i \le 5\times 10^5$，$1 \le l \le r \le 10^{12}$。
\begin{lstlisting}
void solve()
{
	cin>>n>>l>>r;l--;
	for(int i=1;i<=n;i++)
		cin>>p[i];
	sort(p+1,p+1+n);
	for(int i=0;i<p[1];i++)
		for(int j=2;j<=n;j++)
			add(i,(i+p[j])%p[1],p[j]);
	dij(0);
	ll ans=0;
	for(int i=0;i<p[1];i++)
	{
		ll R=(r-dis[i])/p[1]+1;
		ll L=(l-dis[i])/p[1]+1;
		if(r<dis[i])R=0;
		if(l<dis[i])L=0;
		ans+=R-L;
	}
	cout<<ans<<endl;
}
/*
in：
2 5 10
3 5
out:
5
*/
\end{lstlisting}